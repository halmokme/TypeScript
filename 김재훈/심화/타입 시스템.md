### 타입스크립트의 역할

<br/>

#### 1. 런타임에서 발생할 오류를 컴파일 단계에서 표시해준다.

<br/>

#### 2. 런타임에서 오류를 발생시키지 않더라도 에러를 표시한다

```
const Button = () => {
  return <button onclick={() => {}}></button>;
}
```

리액트에서는 onclick을 camelCase로 작성해야 하지만, 위와 같이 lowerCase로 사용했을 때 JS에서는 에러를 띄워주지 않는다. 하지만 TS에서는 이 상황에서 소문자 onclick은 존재하지 않는다는 에러를 띄워준다.

<br/>

그리고 타입스크립트를 하면서 마주하는 오류의 80%는 'Type A is not assignable to Type B'이다. 타입 A는 타입 B에 할당할 수 없다는 오류인데 타입스크립트의 타입 시스템을 분석해보며 이 에러가 정확히 무엇을 의미하고, 어떻게 해결할 수 있는지 살펴보자

<br/>
<br/>

### 타입 시스템

<br/>

#### 1. 구조적 서브 타이핑(structural sub typing)

Type compatibility in TypeScript is based on structural subtyping. (공식문서 발췌)
-> 타입 호환성은 구조적 서브 타이핑에 기반하고 있다.
말이 어려운데 구조적 서브 타이핑이란 속성 기반 타이핑이다(structural subtyping === property-based typing). 예제를 통해 설명해보자

```ts
interface Crew {
  name: string;
  language: "Java" | "JavaScript";
  coach: "poco" | "gugu";
}

interface Coach {
  name: string;
  language: "Java" | "JavaScript";
}

const crew: Crew = {
  name: "gugu",
  language: "JavaScript",
  coach: "gugu",
};

const coach: Coach = {
  name: "poco",
  language: "JavaScript",
};

function doCoding(person: Coach) {
  return `${person.name}이 ${person.language}를 다룹니다.`;
}

// 실행
doCoding(coach);
doCoding(crew);
```

둘 다 정상적으로 실행이 되는데 여기서 의문을 가질 수 있다.
doCoding의 매개변수에는 Coach 타입으로 지정해두었는데, doCoding(crew)가 실행되는 이유?
-> Crew ⊂ Coach가 성립되기 때문.
이걸 구조적 서브 타이핑(Structural Subtyping)이라고 한다.

더 쉽게 말하자면 Super type에 Sub type이 들어갈 수 있는 타입시스템이 구조적 서브 타이핑이다.
타입을 집합 관점에서 바라보면 Sub type ⊂ Super type이 된다.

<br/>
퀴즈) 다음 두 타입 중 Super type과 Sub type은 각각 무엇일까?

```ts
// 1
type StrNum = string | number;
type Str = string;

// 2
interface A {
  a: string;
}
interface AB {
  a: string;
  b: string;
}
```

첫번째 문제의 정답은 Str ⊂ StrNum이다. StrNum에는 'asdfasdba' / 3 두가지가 들어갈 수 있지만, Str에는 3이 들어갈 수 없다. StrNum에 더 많은 값이 들어갈 수 있으므로 전자가 더 상위집합이다.

두번째 문제의 정답은 AB ⊂ A이다. 비유를 하자면 A는 JS를 다룰 수 있는 개발자 집합이고, AB는 전체 개발자 중 JS와 Java를 다룰 수 있는 개발자 집합이다. 당연히 A가 더 큰 타입이다. AB는 b를 추가함으로써 범위가 줄어든 것.
즉 타입을 집합 관점에서 바라봐야 한다.

<br/>

그렇다면 집합 중 가장 작은 집합은? 공집합(원소가 0개인 집합)이다. 이것을 타입으로 표현하면 never 타입이다. never 타입을 코드로 작성하면 type EmptySet = string & number 이 된다.

다음으로 집합의 원소가 1개인 타입은? 리터럴 타입이다.

```ts
type One = "asbasdf";
type One = 2023;
type One = true;
```

집합의 원소가 2개인 타입은 union으로 정의하면 되고

```ts
type Two = "abc" | "def";
type Two = "2023" | "April";
type Two = true | false;
```

집합의 원소가 3개인 타입은 하나 더 늘어나겠지.

그렇다면 이 모든 타입의 상위 집합인 타입은? 바로 unknown이다. 모든 타입에 호환이 되는 가장 큰 집합이다.

```ts
let unknownType: unknown;
unknownType = 1;
unknownType = 'asbasg';
unknownType = true;
unknownType = { name: 'jaehoon' };
unknownType = () => { ... };
```

그럼 any는 ??? 뒤에 설명함

<br/>

여기까지 구조적 서브 타이핑에 관한 얘기였고, 이 다음에 나오는 두가지는 구조적 서브 타이핑을 거스르는 경우이다. 타입스크립트에서는 이것을 거스르는 경우가 더 효율적이라고 판단해서 그렇게 설계한 부분이 있다.

#### 2. 잉여 속성 체크(excess property check)

정의한 속성 이외에 추가적인(잉여) 속성이 있는지 체크하고, 있다면 에러를 띄운다. 코드 예시를 통해 살펴보자

```ts
interface Options {
  title: string;
  darkMode?: boolean;
}

function returnOptions(options: Options) {
  return options;
}

//
```

<br/>

#### 3. any
